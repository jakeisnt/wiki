<!DOCTYPE HTML>
<html><head><title>SMT - Jacob Chvatal&#39;s Wiki</title><link rel="stylesheet" type="text/css" href="https://jakeisnt.github.io/styles/main.css"></head><body><h1 class="title">SMT</h1><p><a href="https://jix.one/the-assembly-language-of-satisfiability.html">src - maybe?</a></p>
<h1>SAT solvers</h1>
<h2>Cons</h2>
<ul>
<li>Require input problem to be a propositional logic formula in conjunctive normal form (CNF). This is not a natural way to express most problems that require SAT</li>
<li>Computing CNF formulas is often bad and hard so SAT solvers aren't really at the right "level" for use by the working programmer</li>
<li>Look up `cardinality constraints CNF` on google scholar - reveals lots of problems and tradeoffs that can be made</li>
</ul>
<h2>Why SMT over SAT?</h2>
<ul>
<li>SMT solvers allow more freedom in the expression of input problems - support integers, fixed width floats, arrays and potentially other datatypes, as well as common operations on those types, without requiring a specific normal form!</li>
<li>API that allows for the manipulation of the input formula exposed by the solver, unlike strict</li>
</ul>
<h2>How do they work?</h2>
<h3>Bit blasting</h3>
<ul>
<li>Directly convert input formula into an equivalent Boolean formula in CNF</li>
<li>Limited to formulas where every data type has a finite set of values</li>
<li>Need a SAT solver as a backend, any improvement to SAT translates directly to an improvement to an SMT solver - so this is just additional tooling around a SAT solver to make it much easier to use.</li>
</ul>
<h3>CDCL(T)</h3>
<ul>
<li>Definition: conflict driven cause learning - the algorithm employed by most modern SAT solvers.</li>
</ul></body></html>