<!DOCTYPE HTML>
<html><head><title>Jacob Chvatal&#39;s Wiki - Jacob Chvatal&#39;s Wiki</title><link rel="stylesheet" type="text/css" href="https://jakeisnt.github.io/styles/main.css"></head><body><h1 class="title">Jacob Chvatal&#39;s Wiki</h1><p><a href="https://vimeo.com/511271022">project cambria</a></p>
<ul>
<li>api request -&gt; stack of transformations -&gt; sent to application logic back and forth</li>
<li>this allows older apis to transform up the stack into a modern server</li>
<li>when distributing: need compatibility of multiple schemas</li>
<li>what would it look like to have good tools for handling distributed systems in a systematic way? (shotgun parsing - parsing by if statements - riddling code with little tests and hoping things stick. tools like protobuf in the long term means only adding optional fields, and eventually the data schema has entirely optional types - how do you know what's still relevant at all?)</li>
<li>manage schema compatibility separate from application logic!
<ul>
<li>provide data transformations; 'bidirectional lenses' - one transformation for the whole schema, as written in a DSL.</li>
<li>graph of connected schemas and associated lenses. show how the schemas connect with those lenses</li>
</ul></li>
<li>cambria then:
<ul>
<li>automatically translates data at runtime</li>
<li>provides ts type definitions as well as JSON schemas for your code. json's checkable at runtime as needed!</li>
<li>integration with Automerge CRDT</li>
</ul></li>
<li>what is the pushpin architecture (from ink and switch?)</li>
</ul></body></html>